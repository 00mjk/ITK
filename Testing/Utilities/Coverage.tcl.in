
source Testing/Utilities/Utility.conf
source Testing/Utilities/Utility.tcl


set HTMLDir [file join Testing HTML]
set TempDir [file join Testing Temporary]

set SiteDir [file join $HTMLDir TestingResults Sites $Site]
set BuildNameDir [file join $SiteDir $BuildName]

set BuildRoot [pwd]

# Find the build name directory
set Status [catch { set BuildStampDirs [glob [file join $BuildNameDir *] ] } Result]
if { $Status == 1 } \
{
  puts stderr "Could not find any builds in the $BuildNameDir to do testing $Result"
  exit 1
}

set BuildStampDir [lindex [lsort $BuildStampDirs] end]
set BuildStamp [file tail $BuildStampDir]
set XMLDir [file join $BuildStampDir XML]

# We can assume that Testing/HTML/TestingResults/@SITE@ is built
file mkdir $HTMLDir $SiteDir $BuildNameDir $BuildStampDir $TempDir $XMLDir


set Out [open [file join $XMLDir Coverage.xml] w]


catch { unset Coverage }

# Clean out the build directory files
# puts "Currently in $BuildRoot"

cd Testing/Utilities
cd $SourceDirectory
set BuildDirectory $BuildRoot
set SourceDirectory [pwd]
set Coverage(BuildDirectory) $BuildRoot
set Coverage(SourceDirectory) [pwd]


# puts "Currently in [pwd]"

set Counter 0

proc GCov { file } \
{
  set dir [pwd]
  cd [file dir $file]
  catch { exec gcov [file tail $file] }
  cd $dir
}

proc AddFile { file } \
{
  global Files
  lappend Files([file tail $file]) $file
}



# First run gcov on each *.da file
# Next index all *.cxx, *.h, *.txx, *.c
cd $BuildRoot
FileMap [glob *] [list *.bb] GCov
FileMap [glob *] [list *.gcov] AddFile

cd $SourceDirectory
set Queue [glob *]
set id "File[incr Counter]"
set TopLevelID $id
set Coverage($id,FileList) [list]
set Coverage($id,DirList) [list]
set Coverage($id,Name) .
set Coverage($id,FullPath) .
set Coverage(.,ID) $id



while { [llength $Queue] != 0 } \
{
  set Filename [lindex $Queue 0]
  set Queue [lrange $Queue 1 end]

  if { [file isdirectory $Filename] } \
  {
    if { [file tail $Filename] == "CVS" } \
    {
      continue
    }
    set id "File[incr Counter]"
    set Coverage($id,FileList) [list]
    set Coverage($id,DirList) [list]
    set Coverage($id,Name) [file tail $Filename]
    set Coverage($id,FullPath) $Filename
    set Coverage($Filename,ID) $id
    set ParentID $Coverage([file dir $Filename],ID)
    lappend Coverage($ParentID,DirList) $id

    
    catch { set Queue [concat $Queue [glob $Filename/*]] }
    continue;
  }
  switch [file extension $Filename] \
  {
    .h - 
    .c - 
    .txx - 
    .cxx 
    {
      if { [info exists Files([file tail $Filename].gcov)] } \
      {
	set FN [file tail $Filename].gcov
	if { [llength $Files($FN)] > 1 } \
	{
	  # Try to find the matching one
	  foreach d $Files($FN) \
	  {
	    if { [string match [file dir $d] [file dir $Filename]] } \
	    {
	      set Files($FN) $d
	      break
	    }
	  }
	}
	  
	set FileCovered 0
	set FileCoverage 0.0

	set id "File[incr Counter]"
	set Coverage($id,Coverage) $FileCoverage
	set Coverage($id,Covered) false
	set Coverage($id,Name) [file tail $Filename]
	set Coverage($id,FullPath) $Filename
	set Coverage($id,GCovFullPath) $Files($FN)
	set ParentID $Coverage([file dir $Filename],ID)
	lappend Coverage($ParentID,FileList) $id

      }
    }
  }
}

proc PercentCoverage { t ut } \
{
  if { ( $ut + $t ) != 0 } \
  {
    return [format "%.2f" [expr 100.0 * $t / double ( $ut + $t )]]
  }
  return 0.00;
}

proc LOC { id } \
{
  global Coverage
  set file $Coverage($id,FullPath)

  set gcov $Coverage($id,GCovFullPath)
  set Untested 0
  set Tested 0
  
  # puts "Testing (in [pwd]) $gcov [file exists $gcov]"
  
  if { [file exists $gcov] } \
  {
    # puts "Opening $gcov"
    set f [open $gcov r]
    while { ![eof $f] } \
    {
      set l [gets $f]
      if { [regexp "\#\#\#\#\#" $l] } \
      {
	incr Untested
      }
      if { [regexp {^[ ]*[0-9][0-9]*} $l] } \
      {
	incr Tested
      }
    }
    close $f
  }
  set Coverage($id,Tested) $Tested
  set Coverage($id,Untested) $Untested
  return [list $Tested $Untested]
}

proc RollUpCoverage { id } \
{
  global Coverage
  set DirCoverage 0
  set DirFiles 0
  set Coverage($id,Tested) 0
  set Coverage($id,Untested) 0
  foreach Dir $Coverage($id,DirList) \
  {
    RollUpCoverage $Dir
    set DirCoverage [expr $DirCoverage + $Coverage($Dir,Coverage)]
    incr DirFiles $Coverage($Dir,FileCount)
    incr Coverage($id,Tested) $Coverage($Dir,Tested)
    incr Coverage($id,Untested) $Coverage($Dir,Untested)
  }
  foreach File $Coverage($id,FileList) \
  {
    set t [LOC $File]
    set Tested [lindex $t 0]
    set Untested [lindex $t 1]
    set DirCoverage [expr $DirCoverage + $Coverage($File,Coverage)]
    set Coverage($File,Tested) $Tested
    set Coverage($File,Untested) $Untested
    incr Coverage($id,Tested) $Tested
    incr Coverage($id,Untested) $Untested
    incr DirFiles
  }
  set Coverage($id,Coverage) 0.0
  if { $Coverage($id,Tested) != 0 && $Coverage($id,Untested) != 0} \
  {
    set Coverage($id,Coverage) [expr $Coverage($id,Tested) / double ( $Coverage($id,Tested) + $Coverage($id,Untested))]
  }
  set Coverage($id,FileCount) $DirFiles
}

cd $BuildRoot
RollUpCoverage $TopLevelID

# parray Coverage

proc Indent { i } \
{
  set r ""
  for { set j 0 } { $j < $i } { incr j } \
  {
    set r "\t$r"
  }
  return $r
}

proc EmitXML { id Out indent } \
{
  global Coverage

  if { $Coverage($id,FileCount) == 0 } \
  {
    return;
  }
  puts $Out "[Indent $indent]<Directory Name=\"$Coverage($id,Name)\" FullPath=\"$Coverage($id,FullPath)\">"
  incr indent
  puts $Out "[Indent $indent]<LOCTested>$Coverage($id,Tested)</LOCTested>"
  puts $Out "[Indent $indent]<LOCUntested>$Coverage($id,Untested)</LOCUntested>"
  puts $Out "[Indent $indent]<PercentCoverage>[PercentCoverage $Coverage($id,Tested) $Coverage($id,Untested)]</PercentCoverage>"
  puts $Out "[Indent $indent]<LOC>[expr $Coverage($id,Untested) + $Coverage($id,Tested)]</LOC>"
  
  foreach File $Coverage($id,FileList) \
  {
    set Covered false
    if { ( $Coverage($File,Untested) + $Coverage($File,Tested) ) > 0 } \
    {
      set Covered true
    }
    puts $Out "[Indent $indent]<File Name=\"$Coverage($File,Name)\"  FullPath=\"$Coverage($id,FullPath)\" Covered=\"$Covered\">"
    
    incr indent
    puts $Out "[Indent $indent]<LOCTested>$Coverage($File,Tested)</LOCTested>"
    puts $Out "[Indent $indent]<LOCUntested>$Coverage($File,Untested)</LOCUntested>"
    puts $Out "[Indent $indent]<PercentCoverage>[PercentCoverage $Coverage($File,Tested) $Coverage($File,Untested)]</PercentCoverage>"
    if { $Coverage($File,GCovFullPath) != "" } \
    {
      puts $Out "[Indent $indent]<GCovFile>$Coverage($File,GCovFullPath)</GCovFile>"
    }
    incr indent -1
    puts $Out "[Indent $indent]</File>"
  }
  foreach Dir $Coverage($id,DirList) \
  {
    EmitXML $Dir $Out $indent
  }

  incr indent -1
  puts $Out "[Indent $indent]</Directory>"
  return
}


puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out {<Coverage>}
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"
puts $Out "\t<LOCTested>$Coverage($TopLevelID,Tested)</LOCTested>"
puts $Out "\t<LOCUntested>$Coverage($TopLevelID,Untested)</LOCUntested>"
puts $Out "\t<LOC>[expr $Coverage($TopLevelID,Untested) + $Coverage($TopLevelID,Tested)]</LOC>"


puts $Out "\t<PercentCoverage>[PercentCoverage $Coverage($TopLevelID,Tested) $Coverage($TopLevelID,Untested)]</PercentCoverage>"

  EmitXML $TopLevelID $Out 1


puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Coverage>"
puts $Out "</Site>"


close $Out
exit

















# Clean out the build directory files
# set Queue [glob [file join Code *]]
# while { [llength $Queue] != 0 } \
# {
#   set Filename [lindex $Queue 0]
#   set Queue [lrange $Queue 1 end]

#   if { [file isdirectory $Filename] } \
#   {
#     catch { set Queue [concat $Queue [glob $Filename/*]] }
#     continue;
#   }
#   switch { [file tail $Filename] } \
#   {
#     .bb -
#     .bbg -
#     .gcov -
#     .da \
#     {
#       file remove $Filename
#     }
#   }
# }

# set Queue [glob [file join Testing *]]
# while { [llength $Queue] != 0 } \
# {
#   # pop off first item
#   set Filename [lindex $Queue 0]
#   set Queue [lrange $Queue 1 end]

#   if { [file isdirectory $Filename] } \
#   {
#     catch { set Queue [concat $Queue [glob $Filename/*]] }
#     continue;
#   }
#   if { [file executable $Filename] } \
#   {
#     # We don't care about the exit status of this test
#     catch { exec $Filename }
#   }
# }
