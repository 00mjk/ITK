
source Testing/Utilities/Utility.conf
source Testing/Utilities/Utility.tcl

set Model Experimental
if { $argc > 0 } \
{
  set Model [lindex $argv 0]
}

set HTMLDir [file join Testing HTML]
set TempDir [file join Testing Temporary]

set SiteDir [file join $HTMLDir TestingResults Sites $Site]
set BuildNameDir [file join $SiteDir $BuildName]

set BuildRoot [pwd]

# Find the build name directory
set BuildStampDir [GetLastBuildDirectory $Model]
if { $BuildStampDir == "" } \
{
  puts stderr "Could not find any builds in the $BuildNameDir to do testing $Result"
  exit 1
}

set BuildStamp [file tail $BuildStampDir]
set XMLDir [file join $BuildStampDir XML]

# We can assume that Testing/HTML/TestingResults/@SITE@ is built
file mkdir $HTMLDir $SiteDir $BuildNameDir $BuildStampDir $TempDir $XMLDir


set Out [open [file join $XMLDir Coverage.xml] w]

catch { unset Coverage }

# Clean out the build directory files
# puts "Currently in $BuildRoot"

cd $SourceDirectory
set BuildDirectory $BuildRoot
set SourceDirectory [pwd]
set Coverage(BuildDirectory) $BuildRoot
set Coverage(SourceDirectory) [pwd]


# puts "Currently in [pwd]"

set Counter 0

proc GCov { file } \
{
  set dir [pwd]
  cd [file dir $file]
  catch { exec gcov -l [file tail $file] }
  cd $dir
}

proc AddFile { file } \
{
  global GCovFiles
  set GCovFiles($file) $file
}

proc AddSourceFile { file } \
{
  global Source
  lappend Source $file
}


proc PercentCoverage { t ut } \
{
  if { ( $ut + $t ) != 0 } \
  {
    return [format "%.2f" [expr 100.0 * $t / double ( $ut + $t )]]
  }
  return 0.00;
}

proc LOC { file } \
{
  global Coverage GCovFiles
  
  set Untested 0
  set Tested 0
  set Covered false
  set pattern [file join *[file tail $file].gcov]
  
  foreach name [array names GCovFiles $pattern] \
  {
    set Covered true
    # puts "\tAdding up $GCovFiles($name)"
    set f [open $GCovFiles($name) r]
    set LineCounter 0
    while { ![eof $f] } \
    {
      if { ![info exists Line($LineCounter)] } \
      {
	set Line($LineCounter) ""
      }
      set l [gets $f]
      if { [regexp "\#\#\#\#\#" $l] } \
      {
	if { $Line($LineCounter) == "" } \
	{
	  set Line($LineCounter) 0
	}
      }
      if { [regexp {^[ ]*[0-9][0-9]*} $l] } \
      {
	if { $Line($LineCounter) == "" } \
	{
	  set Line($LineCounter) 1
	}
      }
      incr LineCounter
    }
    close $f
  }

  set Coverage($file,IsCovered) $Covered
  set Coverage($file,UnCovered) 0
  set Coverage($file,Covered) 0
  foreach i [array names Line] \
  {
    if { $Line($i) == 0 } \
    {
      incr Coverage($file,UnCovered)
    }
    if { $Line($i) >= 1 } \
    {
      incr Coverage($file,Covered)
    }
  }
  incr Coverage(UnCovered) $Coverage($file,UnCovered)
  incr Coverage(Covered) $Coverage($file,Covered)
  
  
}

proc RollUpCoverage { id } \
{
  global Coverage
  set DirCoverage 0
  set DirFiles 0
  set Coverage($id,Tested) 0
  set Coverage($id,Untested) 0
  foreach Dir $Coverage($id,DirList) \
  {
    RollUpCoverage $Dir
    set DirCoverage [expr $DirCoverage + $Coverage($Dir,Coverage)]
    incr DirFiles $Coverage($Dir,FileCount)
    incr Coverage($id,Tested) $Coverage($Dir,Tested)
    incr Coverage($id,Untested) $Coverage($Dir,Untested)
  }
  foreach File $Coverage($id,FileList) \
  {
    set t [LOC $File]
    set Tested [lindex $t 0]
    set Untested [lindex $t 1]
    set DirCoverage [expr $DirCoverage + $Coverage($File,Coverage)]
    set Coverage($File,Tested) $Tested
    set Coverage($File,Untested) $Untested
    incr Coverage($id,Tested) $Tested
    incr Coverage($id,Untested) $Untested
    incr DirFiles
  }
  set Coverage($id,Coverage) 0
  if { $Coverage($id,Tested) != 0 && $Coverage($id,Untested) != 0} \
  {
    set Coverage($id,Coverage) [expr $Coverage($id,Tested) / double ( $Coverage($id,Tested) + $Coverage($id,Untested))]
  }
  set Coverage($id,FileCount) $DirFiles
}



# First run gcov on each *.da file
# Next index all *.cxx, *.h, *.txx, *.c
cd $BuildRoot
FileMap [glob *] [list *.bb] GCov
FileMap [glob *] [list *.gcov] AddFile

set Coverage(UnCovered) 0
set Coverage(Covered) 0

cd $SourceDirectory
FileMap [glob *] [list *.h *.cxx *.c *.txx] AddSourceFile


puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out {<Coverage>}
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"


cd $BuildRoot
foreach file $Source \
{
  # puts "Looking at $file"
  # Find all of the .gcov files associated, and roll up coverage
  LOC $file
  puts $Out "\t<File Name=\"[file tail $file]\" FullPath=\"$file\" Covered=\"$Coverage($file,IsCovered)\">"
  puts $Out "\t\t<LOCTested>$Coverage($file,Covered)</LOCTested>"
  puts $Out "\t\t<LOCUnTested>$Coverage($file,UnCovered)</LOCUnTested>"
  puts $Out "\t\t<PercentCoverage>[PercentCoverage $Coverage($file,Covered) $Coverage($file,UnCovered)]</PercentCoverage>"
  puts $Out "\t</File>"
  
}

puts $Out "\t<LOCTested>$Coverage(Covered)</LOCTested>"
puts $Out "\t<LOCUntested>$Coverage(UnCovered)</LOCUntested>"
puts $Out "\t<LOC>[expr $Coverage(UnCovered) + $Coverage(Covered)]</LOC>"


puts $Out "\t<PercentCoverage>[PercentCoverage $Coverage(Covered) $Coverage(UnCovered)]</PercentCoverage>"


puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Coverage>"
puts $Out "</Site>"


close $Out
puts "File is $XMLDir/Coverage.xml"

exit
cd $BuildRoot
RollUpCoverage $TopLevelID

# parray Coverage

proc Indent { i } \
{
  set r ""
  for { set j 0 } { $j < $i } { incr j } \
  {
    set r "\t$r"
  }
  return $r
}

proc EmitXML { id Out indent } \
{
  global Coverage

  if { $Coverage($id,FileCount) == 0 } \
  {
    return;
  }
  puts $Out "[Indent $indent]<Directory Name=\"$Coverage($id,Name)\" FullPath=\"$Coverage($id,FullPath)\">"
  incr indent
  puts $Out "[Indent $indent]<LOCTested>$Coverage($id,Tested)</LOCTested>"
  puts $Out "[Indent $indent]<LOCUntested>$Coverage($id,Untested)</LOCUntested>"
  puts $Out "[Indent $indent]<PercentCoverage>[PercentCoverage $Coverage($id,Tested) $Coverage($id,Untested)]</PercentCoverage>"
  puts $Out "[Indent $indent]<LOC>[expr $Coverage($id,Untested) + $Coverage($id,Tested)]</LOC>"
  
  foreach File $Coverage($id,FileList) \
  {
    set Covered false
    if { ( $Coverage($File,Untested) + $Coverage($File,Tested) ) > 0 } \
    {
      set Covered true
    }
    puts $Out "[Indent $indent]<File Name=\"$Coverage($File,Name)\"  FullPath=\"$Coverage($id,FullPath)\" Covered=\"$Covered\">"
    
    incr indent
    puts $Out "[Indent $indent]<LOCTested>$Coverage($File,Tested)</LOCTested>"
    puts $Out "[Indent $indent]<LOCUntested>$Coverage($File,Untested)</LOCUntested>"
    puts $Out "[Indent $indent]<PercentCoverage>[PercentCoverage $Coverage($File,Tested) $Coverage($File,Untested)]</PercentCoverage>"
    if { $Coverage($File,GCovFullPath) != "" } \
    {
      puts $Out "[Indent $indent]<GCovFile>$Coverage($File,GCovFullPath)</GCovFile>"
    }
    incr indent -1
    puts $Out "[Indent $indent]</File>"
  }
  foreach Dir $Coverage($id,DirList) \
  {
    EmitXML $Dir $Out $indent
  }

  incr indent -1
  puts $Out "[Indent $indent]</Directory>"
  return
}


puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out {<Coverage>}
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"
puts $Out "\t<LOCTested>$Coverage(Covered)</LOCTested>"
puts $Out "\t<LOCUntested>$Coverage(UnCovered)</LOCUntested>"
puts $Out "\t<LOC>[expr $Coverage(UnCovered) + $Coverage(Covered)]</LOC>"


puts $Out "\t<PercentCoverage>[PercentCoverage $Coverage($TopLevelID,Tested) $Coverage($TopLevelID,Untested)]</PercentCoverage>"

foreach file 

puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Coverage>"
puts $Out "</Site>"


close $Out
exit

















# Clean out the build directory files
# set Queue [glob [file join Code *]]
# while { [llength $Queue] != 0 } \
# {
#   set Filename [lindex $Queue 0]
#   set Queue [lrange $Queue 1 end]

#   if { [file isdirectory $Filename] } \
#   {
#     catch { set Queue [concat $Queue [glob $Filename/*]] }
#     continue;
#   }
#   switch { [file tail $Filename] } \
#   {
#     .bb -
#     .bbg -
#     .gcov -
#     .da \
#     {
#       file remove $Filename
#     }
#   }
# }

# set Queue [glob [file join Testing *]]
# while { [llength $Queue] != 0 } \
# {
#   # pop off first item
#   set Filename [lindex $Queue 0]
#   set Queue [lrange $Queue 1 end]

#   if { [file isdirectory $Filename] } \
#   {
#     catch { set Queue [concat $Queue [glob $Filename/*]] }
#     continue;
#   }
#   if { [file executable $Filename] } \
#   {
#     # We don't care about the exit status of this test
#     catch { exec $Filename }
#   }
# }
