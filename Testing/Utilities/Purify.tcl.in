# =========================================================================
# 
#   Program:   Insight Segmentation & Registration Toolkit
#   Module:    Purify.tcl.in
#   Language:  Tcl
#   Date:      $Date$
#   Version:   $Revision$
# 

# Copyright (c) 2001 Insight Consortium
# All rights reserved.

# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:

#  * Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.

#  * Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.

#  * The name of the Insight Consortium, nor the names of any consortium members,
#    nor of any contributors, may be used to endorse or promote products derived
#    from this software without specific prior written permission.

#   * Modified source versions must be plainly marked as such, and must not be
#     misrepresented as being the original software.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

source [file join Testing Utilities Utility.conf]
source [file join Testing Utilities Utility.tcl]

set Model Experimental
if { $argc > 0 } \
{
  set Model [lindex $argv 0]
}

set HTMLDir [file join Testing HTML]
set TempDir [file join Testing Temporary]
set UtilitiesDirectory [file join Testing Utilities]

set SiteDir [file join $HTMLDir TestingResults Sites $Site]
set BuildNameDir [file join $SiteDir $BuildName]
# Find the build name directory
set BuildStampDir [GetLastBuildDirectory $Model]
if { $BuildStampDir == "" } \
{
  puts  "\tCould not find any builds in the $BuildNameDir to do testing"
  exit 1
}

set BuildStamp [file tail $BuildStampDir]
set XMLDir [file join $BuildStampDir XML]

set Out [open [file join $XMLDir Purify.xml] w]

puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out "<Purify>"
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"

# Find the list of canidate tests
puts "\tFinding Tests to run Purify on"
set TestList ""
set OldDir [pwd]
cd $SourceDirectory
FindTests .
cd $OldDir
puts "\tFound [llength $TestList] tests for Purify"

proc RemoveFile { file } \
{
  file delete -force -- $file
}

# Delete any old coverage files
catch { FileMap [glob -nocomplain *] [list *.plog] RemoveFile } Result

# Write the list
puts $Out "\t<TestList>"
foreach Test $TestList \
{
  puts $Out "\t\t<Test>[XMLSafeString $Test]</Test>"
}
puts $Out "\t</TestList>"

set Purify(Messages) [list MLK ABR ABW COR FMM FUM FMR FMW MAF UMC UMR]
foreach Message $Purify(Messages) \
{
  set Purify($Message,Count) 0
}

proc ProcessPurify { Test PLog } \
{
  global Purify
  if { ![file exists $PLog] } \
  {
    set Purify($Test,Status) failed
    return
  }
  set f [open $PLog r]

  set Purify($Test,PurifyLog) ""
  foreach Message $Purify(Messages) \
  {
    set Purify($Test,$Message) 0
  }
  while { ![eof $f] } \
  {
    set line [gets $f]
    append Purify($Test,PurifyLog) [XMLSafeString "$line\n"]
    foreach Message $Purify(Messages) \
    {
      if { [regexp "$Message:" $line] } \
      {
	incr Purify($Test,$Message)
	incr Purify($Message,Count)
      }
    }
  }
}

proc CheckFile { Filename } \
{
  return [expr [file exists $Filename] && [file executable $Filename]]
}

# For each test, cd to the directory, and run it.
puts "\tRunning Purify Tests"
set ReportPassed 0
set ReportFailed 0
set ReportNotRun 0
foreach Test $TestList \
{
  cd [file dirname $Test]

  set Filename [file tail $Test]

  switch $tcl_platform(platform) \
  {
    windows \
    {
      if { [regexp cygtclsh [info nameofexecutable]] == 0 } {
        # Windows build
	set NewFilename [file join Release $Filename.exe]
      } else {
        # Cygwin build
        set NewFilename [file join . $Filename]
      }
    }
    default \
    {
      set NewFilename [file join . $Filename]
    }
  }
  
  set Purify($Test,Status) notrun
  set Result ""
  if { [CheckFile $NewFilename] } \
  {
    puts "\tRunning $NewFilename"
    set PurifyOptions "-max-threads=1 -chain-length=20 "
    append PurifyOptions "-suppression-file-names=[file join SourceUtilitiesDirectory .purify] "
    set PLog $NewFilename.plog
    append PurifyOptions "-log-file=$PLog "

    set Status [catch { eval exec $PurifyCommand $PurifyOptions $NewFilename } Result]
    # puts $Result
    set Status [catch { eval exec $NewFilename.pure } Result]
    puts "Run test: $Result"
    set Purify($Test,Status) passed
    ProcessPurify $Test $PLog
  }

  puts $Out "\t<Test Status=\"$Purify($Test,Status)\">"
  puts $Out "\t\t<Name>[XMLSafeString $Filename]</Name>"
  puts $Out "\t\t<Path>[XMLSafeString [file dirname $Test]]</Path>"
  puts $Out "\t\t<FullName>[XMLSafeString $Test]</FullName>"
  puts $Out "\t\t<Results>"
  if { $Purify($Test,Status) == "passed" } \
  {
    foreach Message $Purify(Messages) \
    {
      puts $Out "\t\t\t<$Message>$Purify($Test,$Message)</$Message>"
    }
  } \
  else \
  {
    foreach Message $Purify(Messages) \
    {
      puts $Out "\t\t\t<$Message>0</$Message>"
    }
  }
  puts $Out "\t\t</Results>"

  
  if { [file exists $PLog] } \
  {
    set PurifyLog [open $PLog r]

    puts $Out "\t<Log>"
    # For the moment, Don't include the build log
    # puts $Out [Base64Encode [read $BuildLog ]]
    puts $Out [XMLSafeString [read $PurifyLog]]
    close $PurifyLog
    puts $Out "\t</Log>"
  }



  puts $Out "\t</Test>"

  
  cd $OldDir

}

puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Purify>"
puts $Out "</Site>"
set total [expr double($ReportPassed + $ReportFailed + $ReportNotRun)]
puts "\tPurify completed"
foreach Message $Purify(Messages) \
{
  puts "\t\t$Message - $Purify($Message,Count)"
}

close $Out
exit

