# =========================================================================
# 
#   Program:   Insight Segmentation & Registration Toolkit
#   Module:    Utility.tcl.in
#   Language:  Tcl
#   Date:      $Date$
#   Version:   $Revision$
# 
# 
#   Copyright (c) 2000 National Library of Medicine
#   All rights reserved.
# 
#   See COPYRIGHT.txt for copyright details.
# 
# =========================================================================*/


proc MakeDateTimeStamp {} \
{
  return [clock format [clock seconds] -format %Y%m%d%H%M -gmt 1]
}

proc MakeDateStamp {} \
{
  return [clock format [clock seconds] -format %Y%m%d -gmt 1]
}

proc NeedToRemake { File } \
{
  set XML [file join XML $File.xml]
  if { ![file exists $File.html] } \
  {
    # puts "Remake 1"
    return 1
  }
  
  if { [file exists $XML] } \
  {
    # puts "Remake: [expr [file mtime $File.html] <= [file mtime $XML]]"
    return [expr [file mtime $File.html] <= [file mtime $XML]]
  }

  if { [file exists $File.xml] } \
  {
    # puts "Remake: [expr [file mtime $File.html] <= [file mtime $File.xml]]"
    return [expr [file mtime $File.html] <= [file mtime $File.xml]]
  }
  return 1
}

proc IsBuildStampInDay { NightlyDateStamp BuildStamp } \
{
  if { [string match *-Nightly $BuildStamp] } \
  {
    if { $NightlyDateStamp == $BuildStamp } \
    {
      return 1
    }
    return 0
  }
  
  # Convert the BuildStamp into something recognizable
  set NTS [ExpandStamp $NightlyDateStamp]

  # From 7:00am on the morning of the NightlyDateStamp + 24 hours
  set Start [expr $NTS + 7 * 60 * 60]
  set End [expr $Start + 24 * 60 * 60]
  
  set BSTS [ExpandStamp $BuildStamp]

  if { $BSTS >= $Start && $BSTS < $End } \
  {
    return 1
  } \
  else \
  {
    return 0
  }
}

proc GetNightlySeconds {} \
{
  set ts [clock seconds]

  # Get the hour in gmt
  set hour [string trimleft [clock format $ts -format %H -gmt 1] 0]
  set t 0
  if { $hour == "" } \
  {
    set hour 0
  }
  if { $hour < 7 } \
  {
    # We still doing the previous day's work
    # so subtract a day
    set t [expr 60 * 60 * 24]
  }
  return [expr [clock seconds] - $t]
}

proc MakeNightlyDateStamp {} \
{
  set t [GetNightlySeconds]
  return [clock format $t -format %Y%m%d -gmt 1]
}

proc ExpandStamp { Stamp } \
{
  set Year [string range $Stamp 0 3]
  set Month [string range $Stamp 4 5]
  set Day [string range $Stamp 6 7]
  if { [string match "*Nightly" $Stamp] } \
  {
    set Seconds [clock scan "$Month/$Day/$Year" -gmt 1]
  } \
  else \
  {
    set Hour [string range $Stamp 8 9]
    set Minute [string range $Stamp 10 11]
    set Seconds [clock scan "$Month/$Day/$Year $Hour:$Minute" -gmt 1]
  }
  return $Seconds
}

proc FileMap { Queue PatternList Map } \
{
  
  while { [llength $Queue] != 0 } \
  {
    set Filename [lindex $Queue 0]
    set Queue [lrange $Queue 1 end]

    if { [file isdirectory $Filename] } \
    {
      if { [file tail $Filename] == "CVS" } \
      {
	continue
      }
      set Status [catch { set Queue [concat $Queue [glob -nocomplain -- [file join $Filename *]]] } Result]
      if { $Status } \
      {
	puts "Caught $Result"
      }
      continue;
    }
    foreach Pattern $PatternList \
    {
      if { [string match $Pattern [file tail $Filename]] } \
      {
	catch { eval $Map $Filename }
      }
    }
  }
}

proc GetYesterdayDateStamp { NightlyDateStamp } \
{
  set ts [ExpandStamp $NightlyDateStamp-Nightly]
  return [clock format [expr $ts - 24 * 60 * 60] -format %Y%m%d -gmt 1]
}

proc GetLastBuildDirectory { {Model Experimental} } \
{
  global Site BuildName
  set HTMLDir [file join Testing HTML]
  set SiteDir [file join $HTMLDir TestingResults Sites $Site]
  set BuildNameDir [file join $SiteDir $BuildName]

  set GlobString 20*
  if { $Model == "Nightly" } \
  {
    set GlobString 20*-Nightly
  }
  set BuildStampDirs ""
  set BuildStampDirs [glob -nocomplain -- [file join $BuildNameDir $GlobString]]
  return [lindex [lsort $BuildStampDirs] end]
}  

proc GetLastDashboardDirectory { {Model Experimental} } \
{
  global Site BuildName

  set GlobString 20*
  if { $Model == "Nightly" } \
  {
    set GlobString 20*-Nightly
  }
  set DashboardDirs ""
  set DashboardDirs [glob -nocomplain -- [file join Testing HTML TestingResults Dashboard $GlobString]]
  return [lindex [lsort $DashboardDirs] end]
}  


proc ExtractBuildLog { Filename } \
{
  global GunzipCommand Buffer

  set File [open $Filename r]
  set Found 0
  set Buffer ""
  
  while { ![eof $File] } \
  {
    set Line [gets $File]
    if { [string match "*</Log*" $Line] } \
    {
      puts "Found $Line"
      set Found 0
    }
    if { $Found } \
    {
      append Buffer "$Line\n"
    }
    if { [string match "*<Log*>*" $Line] } \
    {
      puts "Found $Line"
      set Found 1
    }
  }
  
  if { $Buffer != "" } \
  {
    set uudecode [open |uudecode w]
    puts $uudecode "begin-base64 664 Log.txt.gz" 
    puts -nonewline $uudecode $Buffer
    puts $uudecode "===="
    close $uudecode
    exec gunzip -f Log.txt.gz
  }
  close $File
}
  
proc TransformBuildLog { Filename } \
{
  global GunzipCommand

  set File [open $Filename r]
  set Header [gets $File]
  set Encoding [lindex $Header 0]
  set CompressionType [lindex $Header 1]

  file delete BuildLog.temp
  set BLFilename BuildLog.temp.gz
  set BLFile [open $BLFilename w]
  puts -nonewline $BLFile [base64::decode [read $File]]
  close $BLFile
  file delete $Filename
  if { $GunzipCommand == "" } \
  {
    file rename -force -- BuildLog.temp.gz BuildLog.html.$CompresssionType
    return
  }
  
  switch $CompressionType \
  {
    compress - \
    zip \
    {
      exec $GunzipCommand BuildLog.temp.gz
      file rename -force -- BuildLog.temp BuildLog.txt
      exec $GzipCommand BuildLog.html
    }
    gzip \
    {
      file rename -force -- BuildLog.temp.gz BuildLog.html.gz
    }
  }
}


proc CompressFile { In Out } \
{
  global CompressionCommand CompressionType
  if { $In == $Out } \
  {
    error "CompressFile, can not compress a file to itself $In"
  }
  switch -glob $CompressionCommand \
  {
    *gzip \
    {
      set CompressionType gzip
      return [exec $CompressionCommand -c $In > $Out]
    }
    *compress \
    {
      set CompressionType compress
      return [exec $CompressionCommand -c $In > $Out]
    }
    *zip \
    {
      set CompressionType zip
      return [exec $CompressionCommand - $In > $Out]
    }
    default \
    {
      set CompressionType none
      return [file copy -force $In $Out]
    }
  }
}

proc XMLConcat { FP filename } \
{
  catch {	
    set f [open $filename r]
    set line [gets $f]
    if { ![string match {<?xml*} $line] } \
    {
      puts $FP $line
    }
    puts -nonewline $FP [read $f]
    close $f
  }
}


proc XMLSafeString { string } \
{
  # Here is where all substitutions should be done
  # regsub -all "\"" $string {%quot;} string
  regsub -all "&" $string {\&amp;} string
  regsub -all "<" $string {\&lt;} string
  regsub -all ">" $string {\&gt;} string
  # regsub -all "'" $string {%apos;} string
  return $string
}

proc GetDirectories { dir } \
{
  set result ""
  foreach f [glob -nocomplain -- $dir]
  {
    if { [file isdirectory $f] } \
    {
      lappend result $f
    }
  }
  return $result
}


proc InitBase64 {} \
{
  global Base64
  
  if { [info exists Base64(0)] } { return }
  set String "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
  
  set count [string length $String]
  for { set i 0 } { $i < $count } { incr i } \
  {
    set Base64($i) [string index $String $i]
  }
  set Base64(Pad) "="
}

proc _toU8 { num } \
{
  return [expr ( $num + 0x100 ) % 0x100]
}
 
proc Base64Encode { String } \
{
  global Base64
  InitBase64
  
  set length [string length $String]
  set result ""
  set index 0
  set count 0
  while { $length > 2 } \
  {
    binary scan [string index $String $index] c current0
    set current0 [_toU8 $current0]
    incr index
    binary scan [string index $String $index] c current1
    set current1 [_toU8 $current1]
    incr index
    binary scan [string index $String $index] c current2
    set current2 [_toU8 $current2]
    incr index

    # puts "$current0 $current1 $current2"
        
    append result $Base64([expr $current0 >> 2])   
    append result $Base64([expr (($current0 & 0x03) << 4) + ($current1 >> 4 )])
    append result $Base64([expr (($current1 & 0x0f ) << 2) + ($current2 >> 6) ])
    append result $Base64([expr $current2 & 0x3f])
    incr length -3
  }

  
  if { $length != 0 } \
  {
    # puts "length = $length"
    binary scan [string index $String $index] c current0
    set current0 [_toU8 $current0]
    incr index
    append result $Base64([expr $current0 >> 2])
    if { $length > 1 } \
    {
      binary scan [string index $String $index] c current1
      set current1 [_toU8 $current1]
      incr index
      append result $Base64([expr (($current0 & 0x03) << 4) + ($current1 >> 4)])
      append result $Base64([expr ($current1 & 0x0f) << 2])
      append result $Base64(Pad)      
    } \
    else \
    {
      append result $Base64([expr ($current0 & 0x03) << 4])
      append result $Base64(Pad)
      append result $Base64(Pad)
    }
  }
# if (length != 0) {
#                 result[i++] = base64_table[current[0] >> 2];
#                 if (length > 1) {
#                         result[i++] = base64_table[((current[0] & 0x03) << 4) + (current[1] >> 4)];
#                         result[i++] = base64_table[(current[1] & 0x0f) << 2];
#                         result[i++] = base64_pad;
#                 }
#                 else {
#                         result[i++] = base64_table[(current[0] & 0x03) << 4];
#                         result[i++] = base64_pad;
#                         result[i++] = base64_pad;
#                 }
#           }
  # Break result into 78 character counts
  set length [string length $result]
  set ret ""
  set index 0
  while { $length > 60 } \
  {
    append ret "[string range $result 0 59]\n"
    set result [string range $result 60 end]
    incr length -60
  }
  if { $length != 0 } \
  {
    append ret $result
  }
  return $ret
}

proc Base64EncodeFileToFile { In Out } \
{
  global Base64
  InitBase64
  set length 0
  set result ""
  set index 0
  set count 0
  
  while { ![eof $In] } \
  {
    append String [read $In 2049]
    incr length [string length $String]
    while { $length > 2 } \
    {
      binary scan [string index $String $index] c current0
      set current0 [_toU8 $current0]
      incr index
      binary scan [string index $String $index] c current1
      set current1 [_toU8 $current1]
      incr index
      binary scan [string index $String $index] c current2
      set current2 [_toU8 $current2]
      incr index

      set result ""
      append result $Base64([expr $current0 >> 2])   
      append result $Base64([expr (($current0 & 0x03) << 4) + ($current1 >> 4 )])
      append result $Base64([expr (($current1 & 0x0f ) << 2) + ($current2 >> 6) ])
      append result $Base64([expr $current2 & 0x3f])
      incr length -3
      incr count 4
      puts -nonewline $Out $result
      if { $count >= 78 } \
      {
	puts $Out ""
	set count 0
      }
    }
  }    

  set result ""
  if { $length != 0 } \
  {
    # puts "length = $length"
    binary scan [string index $String $index] c current0
    set current0 [_toU8 $current0]
    incr index
    append result $Base64([expr $current0 >> 2])
    if { $length > 1 } \
    {
      binary scan [string index $String $index] c current1
      set current1 [_toU8 $current1]
      incr index
      append result $Base64([expr (($current0 & 0x03) << 4) + ($current1 >> 4)])
      append result $Base64([expr ($current1 & 0x0f) << 2])
      append result $Base64(Pad)
    } \
    else \
    {
      append result $Base64([expr ($current0 & 0x03) << 4])
      append result $Base64(Pad)
      append result $Base64(Pad)
    }
    incr count 3
  }
  puts $Out $result
}

proc lremove { l item } \
{
  # Return a list with all instances of the item removed
  set ret ""
  foreach element $l \
  {
    if { [string compare $element $item] != 0 } \
    {
      lappend ret $element
    }
  }
  return $ret
}

      
proc Grep { matchlist file { Exceptions {} } } \
{
  set result ""
  foreach line [split $file "\n"] \
  {
    set E 0
    foreach match $matchlist \
    {
      if { [regexp $match $line] } \
      {
	set E 1
	foreach Exception $Exceptions \
	{
	  if { [regexp $Exception $line] } \
	  {
	    set E 0
	  }
	}
	if { $E } \
	{
	  lappend result $line
	  break
	}
      }
    }
  }
  return $result
}

proc Match { match file { Exceptions {} } } \
{
  return [expr [llength [Grep $match $file $Exceptions]] > 0 ]
}


proc GetCMakeVariable { Variable } \
{
  if { ![file exists CMakeLists.txt] } \
  {
    error "No CMakeLists.txt file"
  }
  set Contents ""
  set f [open CMakeLists.txt r]
  set Contents [read $f]
  close $f
  # puts $Contents
  regsub -all "\n" $Contents " " C1
  # puts $C1
  regsub -all {\)} $C1 ")\n " C
  set Contents $C
  
  foreach Line [split $Contents "\n"] \
  {
    if { [string first $Variable $Line] != -1 } \
    {
      set i [expr [string first "(" $Line] + 1]
      set l [string trim [string range $Line $i end]]
      set l [string trim $l "()"]
      return $l
    }
  }
  return ""
}
  
