# =========================================================================
# 
#   Program:   Insight Segmentation & Registration Toolkit
#   Module:    Build.tcl.in
#   Language:  Tcl
#   Date:      $Date$
#   Version:   $Revision$
# 

Copyright (c) 2001 Insight Consortium
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * The name of the Insight Consortium, nor the names of any consortium members,
   nor of any contributors, may be used to endorse or promote products derived
   from this software without specific prior written permission.

  * Modified source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS ``AS IS''
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=========================================================================*/


# Put in this directory
# Year Month Day - TimeZone - Hour:Minute
# e.g. 20000926-EDT-16:02
# or Year Month Day Hour Minute
# clock format [clock seconds] -format %Y%m%d%H%M

# Must be run from root directory of Insight build, only by make

set Model Experimental
if { $argc > 0 } \
{
  set Model [lindex $argv 0]
}

set UtilityDir [file join Testing Utilities]


source [file join $UtilityDir Utility.conf]
source [file join $UtilityDir Utility.tcl]

set HTMLDir [file join Testing HTML]
set BuildTempDir [file join Testing Temporary]
set SiteDir [file join $HTMLDir TestingResults Sites $Site]
set BuildNameDir [file join $SiteDir $BuildName]

set BuildStampDir [GetLastBuildDirectory $Model]
if { $BuildStampDir == "" } \
{
  puts "\tCould not find a BuildStamp in $BuildNameDir"
  exit 1
}
set BuildStamp [file tail $BuildStampDir]
set XMLDir [file join $BuildStampDir XML]


# We can assume that Testing/HTML/TestingResults/@SITE@ is built
file mkdir $HTMLDir $SiteDir $BuildNameDir $BuildStampDir $BuildTempDir $XMLDir

set BuildLogFilename [file join $BuildTempDir Build.log.[pid]]
set BuildLogCompressedFilename [file join $BuildTempDir Build.log.compressed.[pid]]
set BuildLogTempFilename [file join $BuildTempDir Build.log.temp.[pid]]

# Begin the XML output
set Out [open [file join $XMLDir Build.xml] w]

puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
# puts $Out {<!DOCTYPE Insight>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out {<Build>}
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"

# Do the build
puts "\tStarting Build"
set MakeArgs ""
if { [string match "*make" $MakeCommand] } \
{
  set MakeArgs -k
}
set BuildStatus [catch { eval exec $MakeCommand $MakeArgs >& $BuildLogFilename } ]
puts "\tBuild finished with status: $BuildStatus"
puts "\tStarting XML generation"
set Build [open $BuildLogFilename r]
set BuildLog [open $BuildLogTempFilename w]
puts $BuildLog "<html><head><title>Build log: $Site - $BuildName - $BuildStamp</title></head><body bgcolor=\"\#ffffff\">"

set Cache ""
catch { unset ErrorList }
set ErrorList(Counter) 0
set ErrorList(Append) ""
set ErrorList(Buffer) ""
set PostContextCount 5
set BufferLength 5
set Report(Error) 0
set Report(Warning) 0
set Report(FileMatched) 0

  # First match is GNU compiler
  # Second match is IRIX compiler
set ErrorMatches [list \
		  {([^ :]+):([0-9]+): ([^ \t])} \
		  {^cc[^C]*CC: ERROR File = ([^,]+), Line = ([0-9]+)} \
		  {^ld([^:])*:([ \t])*ERROR([^:])*:} \
		  {([^ :]+) : (error|fatal error)} \
		  {([^:]+)\(([^\)]+)\) : (error|fatal error)}
		 ]
set ErrorExceptions [list "instantiated from " "candidates are:"]


set WarningMatches [list \
		    {([^ :]+):([0-9]+): warning:} \
		    {^cc[^C]*CC: WARNING File = ([^,]+), Line = ([0-9]+)} \
  		    {^ld([^:])*:([ \t])*WARNING([^:])*:} \
		    {([^ :]+) : warning}
		 ]
set WarningExceptions [list "WARNING 84 :"]

puts "\tParsing Build Log"
set Line 1
while { ![eof $Build] } \
{
  # Get a line and write it out
  set LogLine [gets $Build]
  # Whate the heck should I do here?!?  Always ends up with extra lines.
  puts $BuildLog "<a name=\"$Line\">$Line:</a><pre>$LogLine</pre>"

  #set hasError [Match {.*[Ee][Rr][Rr][Oo][Rr].*} $LogLine $Exceptions]

  set hasError [Match $ErrorMatches $LogLine $ErrorExceptions]
  
  set hasWarning [Match $WarningMatches $LogLine $WarningExceptions]
  # set hasError [regexp -nocase ".*error.*" $LogLine]
  # set hasWarning [regexp -nocase ".*warning.*" $LogLine]

  if { $hasError } \
  {
    set Type Error
    incr Report(Error)
  }
  
  if { $hasWarning } \
  {
    set Type Warning
    incr Report(Warning)
  }
  if { $hasError || $hasWarning } \
  {
    set i $ErrorList(Counter)
    incr ErrorList(Counter)
    set ErrorList($i,Type) $Type
    set ErrorList($i,Text) $LogLine
    set ErrorList($i,Line) $Line
    set ErrorList($i,PreContext) $ErrorList(Buffer)
    set ErrorList($i,PostContext) ""
    set ErrorList($i,ContextCounter) 0
    set ErrorList($i,SourceFile) ""
    set ErrorList($i,SourceLineNumber) ""

    # Take a stab at getting a file name out of the line
    # For GCC, we get /path/to/source.cxx:##
    # or ../../../Insight/Code/Common
    set Found 0
    if { !$Found && [regexp "${SourceDirectory}/(\[^:\]*):(\[0-9\]+)" $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    if { !$Found && [regexp {/Insight/([^:]*):([0-9]+)} $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    
    # MS VC++ 6.0
    set match {Insight(\\|/)([^\(]*)\(([0-9]+)\) : (error|fatal error|warning)}
      
    if { !$Found && [regexp $match $LogLine dummy dummy2 SourceFile LineNumber] } \
    {
      # Replace all backslashes with forward slashes
      regsub -all {\\([a-zA-Z0-9_])} $SourceFile "/\\1" dummy
      set SourceFile $dummy
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    
    # Irix compiler
    # cc-1552 CC: WARNING File = /home/blezek/src/Insight/Code/Common/itkAffineMutualInformationVW.txx, Line = 250
    if { !$Found && [regexp "${SourceDirectory}/(\[^,\]*), Line = (\[0-9\]+)" $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    incr Report(FileMatched) $Found
    lappend ErrorList(Append) $i
  }
  
  # Add to the PreContextBuffer
  set l [llength $ErrorList(Buffer)]
  if { $l > $BufferLength } \
  {
    set ErrorList(Buffer) [lrange $ErrorList(Buffer) 1 [expr $l - 2]]
  }
  if { [string trim $LogLine] != "" } \
  {
    lappend ErrorList(Buffer) $LogLine
  }

  # Go through all in the ErrorList to append to, and do it
  set AppendList $ErrorList(Append)
  foreach i $AppendList \
  {
    if { $ErrorList($i,Line) != $Line } \
    {
      if { [string trim $LogLine] != "" } \
      {
	lappend ErrorList($i,PostContext) $LogLine
	incr ErrorList($i,ContextCounter)
      }

      # Remove this error for the append list
      if { $ErrorList($i,ContextCounter) > $PostContextCount } \
      {
	set ErrorList(Append) [lremove $ErrorList(Append) $i]
      }
    }
  }
  incr Line
}

  
# Write all the errors out to the Out file
puts "\t\t$Report(Error) Compiler Errors"
puts "\t\t$Report(Warning) Compiler Warnings"
set total [expr $Report(Error) + $Report(Warning)]
if { $total != 0 } \
{
  set percent [format "%.2f" [expr 100.0 * $Report(FileMatched) / double($Report(Error) + $Report(Warning))]]
  puts "\t\tParsed $Report(FileMatched) filenames from [expr $Report(Error) + $Report(Warning)] opportunities for $percent%"
}
puts "\tWriting XML"
for { set i 0 } { $i < $ErrorList(Counter) } { incr i } \
{
  puts $Out "\t<$ErrorList($i,Type)>"
  puts $Out "\t\t<BuildLogLine>[XMLSafeString $ErrorList($i,Line)]</BuildLogLine>"
  puts $Out "\t\t<Text>[XMLSafeString $ErrorList($i,Text)]"
  puts $Out "</Text>"
  if { $ErrorList($i,SourceFile) != "" } \
  {
    puts $Out "\t\t<SourceFile>[XMLSafeString $ErrorList($i,SourceFile)]</SourceFile>"
    puts $Out "\t\t<SourceFileTail>[XMLSafeString [file tail $ErrorList($i,SourceFile)]]</SourceFileTail>"
    puts $Out "\t\t<SourceLineNumber>$ErrorList($i,SourceLineNumber)</SourceLineNumber>"
  }
  puts -nonewline $Out "\t\t<PreContext>"
  foreach l $ErrorList($i,PreContext) \
  {
    puts $Out [XMLSafeString $l]
  }
  puts $Out "</PreContext>"
  puts -nonewline $Out "\t\t<PostContext>"
  foreach l $ErrorList($i,PostContext) \
  {
    puts $Out [XMLSafeString $l]
  }
  puts $Out "</PostContext>"
  puts $Out "</$ErrorList($i,Type)>"
  puts $Out "\n"
}

puts $BuildLog "</body></html>"
close $BuildLog
set LogCompressionStatus [ catch { CompressFile $BuildLogTempFilename $BuildLogCompressedFilename } CompressionResult ]
if { $LogCompressionStatus } \
{
  error $CompressionResult
}

set BuildLog [open $BuildLogCompressedFilename r]
fconfigure $BuildLog -translation binary

puts $Out "\t<Log Encoding=\"base64\" Compression=\"$CompressionType\">"
# For the moment, Don't include the build log
# puts $Out [Base64Encode [read $BuildLog ]]
puts $Out "\t</Log>"
puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Build>"
puts $Out "</Site>"

close $Build
close $BuildLog
close $Out

file delete $BuildLogTempFilename
file delete $BuildLogCompressedFilename
file delete $BuildLogFilename

puts "\tFinished Build"
# Clean up any da files from previous coverage
# FileMap [list .] [list *.da] "file delete -force -- "
exit

