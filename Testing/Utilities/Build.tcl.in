# Put in this directory
# Year Month Day - TimeZone - Hour:Minute
# e.g. 20000926-EDT-16:02
# or Year Month Day Hour Minute
# clock format [clock seconds] -format %Y%m%d%H%M

# Must be run from root directory of Insight build, only by make

set Model Experimental
if { $argc > 0 } \
{
  set Model [lindex $argv 0]
}

set UtilityDir [file join Testing Utilities]


source [file join $UtilityDir Utility.conf]
source [file join $UtilityDir Utility.tcl]

set HTMLDir [file join Testing HTML]
set BuildTempDir [file join Testing Temporary]
set SiteDir [file join $HTMLDir TestingResults Sites $Site]
set BuildNameDir [file join $SiteDir $BuildName]

set BuildStampDir [GetLastBuildDirectory $Model]
if { $BuildStampDir == "" } \
{
  puts stderr "Could not find a BuildStamp in $BuildNameDir"
  exit 1
}
set BuildStamp [file tail $BuildStampDir]
set XMLDir [file join $BuildStampDir XML]

puts "Doing build in $BuildStampDir for BuildStamp $BuildStamp"

# We can assume that Testing/HTML/TestingResults/@SITE@ is built
file mkdir $HTMLDir $SiteDir $BuildNameDir $BuildStampDir $BuildTempDir $XMLDir

set BuildLogFilename [file join $BuildTempDir Build.log.[pid]]
set BuildLogCompressedFilename [file join $BuildTempDir Build.log.compressed.[pid]]
set BuildLogTempFilename [file join $BuildTempDir Build.log.temp.[pid]]

# Begin the XML output
set Out [open [file join $XMLDir Build.xml] w]

puts $Out {<?xml version="1.0" encoding="UTF-8"?>}
# puts $Out {<!DOCTYPE Insight>}
puts $Out "<Site BuildName=\"$BuildName\" BuildStamp=\"$BuildStamp\" Name=\"$Site\">"
puts $Out {<Build>}
puts $Out "\t<StartDateTime>[clock format [clock seconds]]</StartDateTime>"


# Do the build
set MakeArgs ""
if { [string match "*make" $MakeCommand] } \
{
  set MakeArgs -k
}
set BuildStatus [catch { eval exec $MakeCommand $MakeArgs >& $BuildLogFilename } ]

set Build [open $BuildLogFilename r]
set BuildLog [open $BuildLogTempFilename w]
puts $BuildLog "<html><head><title>Build log: $Site - $BuildName - $BuildStamp</title></head><body bgcolor=\"\#ffffff\">"



set Cache ""
catch { unset ErrorList }
set ErrorList(Counter) 0
set ErrorList(Append) ""
set ErrorList(Buffer) ""
set PostContextCount 5
set BufferLength 5


  # First match is GNU compiler
  # Second match is IRIX compiler
set ErrorMatches [list \
		  {([^ :]+):([0-9]+): } \
		  {^cc[^C]*CC: ERROR File = ([^,]+), Line = ([0-9]+)} \
		  {([^ :]+) : (error|fatal error)}
		 ]
set ErrorExceptions [list "instantiated from "]


set WarningMatches [list \
		    {([^ :]+):([0-9]+): warning:} \
		    {^cc[^C]*CC: WARNING File = ([^,]+), Line = ([0-9]+)} \
		    {([^ :]+) : warning}
		 ]
set WarningExceptions [list ]

set Line 1
while { ![eof $Build] } \
{
  # Get a line and write it out
  set LogLine [gets $Build]
  # Whate the heck should I do here?!?  Always ends up with extra lines.
  puts $BuildLog "<a name=\"$Line\">$Line:</a><pre>$LogLine</pre>"

  #set hasError [Match {.*[Ee][Rr][Rr][Oo][Rr].*} $LogLine $Exceptions]

  set hasError [Match $ErrorMatches $LogLine $ErrorExceptions]
  
  set hasWarning [Match $WarningMatches $LogLine $WarningExceptions]
  # set hasError [regexp -nocase ".*error.*" $LogLine]
  # set hasWarning [regexp -nocase ".*warning.*" $LogLine]

  if { $hasError } \
  {
    set Type Error
  }
  if { $hasWarning } \
  {
    set Type Warning
  }
  if { $hasError || $hasWarning } \
  {
    set i $ErrorList(Counter)
    incr ErrorList(Counter)
    set ErrorList($i,Type) $Type
    set ErrorList($i,Text) $LogLine
    set ErrorList($i,Line) $Line
    set ErrorList($i,PreContext) $ErrorList(Buffer)
    set ErrorList($i,PostContext) ""
    set ErrorList($i,ContextCounter) 0
    set ErrorList($i,SourceFile) ""
    set ErrorList($i,SourceLineNumber) ""

    # Take a stab at getting a file name out of the line
    # For GCC, we get /path/to/source.cxx:##
    # or ../../../Insight/Code/Common
    set Found 0
    if { !$Found && [regexp "${SourceDirectory}/(\[^:\]*):(\[0-9\]+)" $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    if { !$Found && [regexp {/Insight/([^:]*):([0-9]+)} $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    
    # MS VC++ 6.0
    set match {Insight(\\|/)([^(]*)\(([0-9]+)\) : (error|fatal error|warning)}
      
    if { !$Found && [regexp $match $LogLine dummy dummy2 SourceFile LineNumber] } \
    {
      # Replace all backslashes with forward slashes
      regsub -all {\\([a-zA-Z0-9_])} $SourceFile "/\\1" dummy
      set SourceFile $dummy
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    
    # Irix compiler
    # cc-1552 CC: WARNING File = /home/blezek/src/Insight/Code/Common/itkAffineMutualInformationVW.txx, Line = 250
    if { !$Found && [regexp "${SourceDirectory}/(\[^,\]*), Line = (\[0-9\]+)" $LogLine dummy SourceFile LineNumber] } \
    {
      set ErrorList($i,SourceFile) $SourceFile
      set ErrorList($i,SourceLineNumber) $LineNumber
      set Found 1
    }
    
    lappend ErrorList(Append) $i
  }

  # Add to the PreContextBuffer
  set l [llength $ErrorList(Buffer)]
  if { $l > $BufferLength } \
  {
    set ErrorList(Buffer) [lrange $ErrorList(Buffer) 1 [expr $l - 2]]
  }
  if { [string trim $LogLine] != "" } \
  {
    lappend ErrorList(Buffer) $LogLine
  }

  # Go through all in the ErrorList to append to, and do it
  set AppendList $ErrorList(Append)
  foreach i $AppendList \
  {
    if { $ErrorList($i,Line) != $Line } \
    {
      if { [string trim $LogLine] != "" } \
      {
	lappend ErrorList($i,PostContext) $LogLine
	incr ErrorList($i,ContextCounter)
      }

      # Remove this error for the append list
      if { $ErrorList($i,ContextCounter) > $PostContextCount } \
      {
	set ErrorList(Append) [lremove $ErrorList(Append) $i]
      }
    }
  }
  incr Line
}

# Write all the errors out to the Out file
for { set i 0 } { $i < $ErrorList(Counter) } { incr i } \
{
  puts $Out "\t<$ErrorList($i,Type)>"
  puts $Out "\t\t<BuildLogLine>[XMLSafeString $ErrorList($i,Line)]</BuildLogLine>"
  puts $Out "\t\t<Text>[XMLSafeString $ErrorList($i,Text)]"
  puts $Out "</Text>"
  if { $ErrorList($i,SourceFile) != "" } \
  {
    puts $Out "\t\t<SourceFile>[XMLSafeString $ErrorList($i,SourceFile)]</SourceFile>"
    puts $Out "\t\t<SourceFileTail>[XMLSafeString [file tail $ErrorList($i,SourceFile)]]</SourceFileTail>"
    puts $Out "\t\t<SourceLineNumber>$ErrorList($i,SourceLineNumber)</SourceLineNumber>"
  }
  puts -nonewline $Out "\t\t<PreContext>"
  foreach l $ErrorList($i,PreContext) \
  {
    puts $Out [XMLSafeString $l]
  }
  puts $Out "</PreContext>"
  puts -nonewline $Out "\t\t<PostContext>"
  foreach l $ErrorList($i,PostContext) \
  {
    puts $Out [XMLSafeString $l]
  }
  puts $Out "</PostContext>"
  puts $Out "</$ErrorList($i,Type)>"
  puts $Out "\n"
}

puts $BuildLog "</body></html>"
close $BuildLog
set LogCompressionStatus [ catch { CompressFile $BuildLogTempFilename $BuildLogCompressedFilename } CompressionResult ]
if { $LogCompressionStatus } \
{
  error $CompressionResult
}

set BuildLog [open $BuildLogCompressedFilename r]
fconfigure $BuildLog -translation binary

puts $Out "\t<Log Encoding=\"base64\" Compression=\"$CompressionType\">"
puts $Out [Base64Encode [read $BuildLog ]]
puts $Out "\t</Log>"
puts $Out "\t<EndDateTime>[clock format [clock seconds]]</EndDateTime>"

puts $Out "</Build>"
puts $Out "</Site>"

close $Build
close $BuildLog
close $Out

file delete $BuildLogTempFilename
file delete $BuildLogCompressedFilename
file delete $BuildLogFilename

# Clean up any da files from previous coverage
# FileMap [list .] [list *.da] "file delete -force -- "
exit

