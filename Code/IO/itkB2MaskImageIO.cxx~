/*=========================================================================
  Program:   Insight Segmentation & Registration Toolkit
  Module:    itkB2MaskImageIO.cxx~
  Language:  C++
  Date:      $Date$
  Version:   $Revision$

  Copyright (c) 2002 Insight Consortium. All rights reserved.
  See ITKCopyright.txt or http://www.itk.org/HTML/Copyright.htm for details.

  This software is distributed WITHOUT ANY WARRANTY; without even
  the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
  PURPOSE.  See the above copyright notices for more information.

  =========================================================================*/

#include "itkB2MaskImageIO.h"
#include "itkExceptionObject.h"
#include "itkByteSwapper.h"
#include "itkIOCommon.h"
#include "itkMetaDataObject.h"

#include <zlib.h>

#include <cstdio>

static const unsigned char DEF_WHITE_MASK=255;
namespace itk
{

  // Default constructor
  B2MaskImageIO::B2MaskImageIO()
  {
    //by default, only have 3 dimensions
    this->SetNumberOfDimensions(3);
    m_PixelType         = UCHAR;
    //The file byte order
    m_MachineByteOrder  = ( ByteSwapper<int>::SystemIsBigEndian() == true ) ? 
      LittleEndian : BigEndian ;
  }

  B2MaskImageIO::~B2MaskImageIO()
  {
    //Purposefully left blank
  }

  void B2MaskImageIO::PrintSelf(std::ostream& os, Indent indent) const
  {
    Superclass::PrintSelf(os, indent);
    os << indent << "PixelType " << m_PixelType << "\n";
  }

  bool B2MaskImageIO::CanWriteFile(const char * FileNameToWrite)
  {
    m_FileName=FileNameToWrite;
    if( ( m_FileName != "" ) &&
        ( m_FileName.find(".mask") < m_FileName.length() )  // Mask name Given
        )
      {
      return true;
      }
    return false;
  }

  const std::type_info& B2MaskImageIO::GetPixelType() const
  {
    return typeid(unsigned char);
  }

  unsigned int B2MaskImageIO::GetComponentSize() const
  {
    return sizeof(unsigned char);
  }

  //The function that is used to read the octree stream to an octree.
  itk::OctreeNodeBranch * B2MaskImageIO::
  readOctree (std::ifstream & octreestream,
              const ImageIOBase::ByteOrder machineByteOrder,
              const ImageIOBase::ByteOrder fileByteOrder)
  {
    //Read in the color to set
    unsigned short int colorCode;
    octreestream.read((char *)&colorCode, sizeof (unsigned short int));
    if (machineByteOrder != fileByteOrder)
      {
      if ( machineByteOrder == LittleEndian )
        {
        ByteSwapper<unsigned short int>::
          SwapFromSystemToBigEndian( &colorCode );
        }
      else if ( machineByteOrder == BigEndian )
        {
        ByteSwapper<unsigned short int>::
          SwapFromSystemToLittleEndian( &colorCode );
        }
      }
    //Create child array of nodes.
    itk::OctreeNodeBranch *CurrentNodeBranch = new itk::OctreeNodeBranch;
    //7766554433221100  ChildID
    //1111110000000000  Bit
    //5432109876543210  Numbers
    for (unsigned int i = ZERO; i <= SEVEN; i++)
      {
      //std::cout << "i=" << i << " Code= " << colorCode << 
      //" Switch statement = " << ((colorCode >> (i << 1)) & 3) <<std::endl;
      //NOTES: the (i << 1) tells how far to shift (i.e. by i*2 bits) for 
      // the current child
      // the & 3 picks off the bottom two bits and treats them as an integer.

      //(colorCode/pow(2,i*2) ) & 00000011b
      switch ((colorCode >> (i << 1)) & 3)  
        {
        case B2_MASKFILE_WHITE: // 0
          CurrentNodeBranch->GetLeaf(static_cast<enum LeafIdentifier>(i))->SetColor(DEF_WHITE_MASK);
          break;
        case B2_MASKFILE_BLACK: // 1
          CurrentNodeBranch->GetLeaf(static_cast<enum LeafIdentifier>(i))->SetColor(0);
          break;
        case B2_MASKFILE_GRAY:  // 2
          //NOTE recursive call on all children to set them.
          CurrentNodeBranch->GetLeaf(static_cast<enum LeafIdentifier>(i))->SetBranch(readOctree(octreestream, machineByteOrder, fileByteOrder));
          break;
        }
      }
    return CurrentNodeBranch;
  }

  void B2MaskImageIO::Read(void* buffer)
  {
    const unsigned int dimensions = this->GetNumberOfDimensions();
    unsigned int numberOfPixels = 1;
    for( unsigned int dim=0; dim< dimensions; dim++ )
      {
      numberOfPixels *= m_Dimensions[ dim ];
      }
    std::ifstream   local_InputStream;
    { //Just fast forward throuth the file header
    itk::B2IPLHeaderInfo DummyHeader;
    local_InputStream.open( this->m_FileName.c_str(), std::ios::in | std::ios::binary );
    if( local_InputStream.fail() )
      {
      ExceptionObject exception(__FILE__, __LINE__);
      exception.SetDescription("File cannot be read");
      throw exception;
      }
    DummyHeader.ReadB2Header(local_InputStream);
    }
    //Actually start reading the octree
    unsigned int octreeHdr[6];
    //Need to gobble up the end of line character here and move one more byte.
    local_InputStream.ignore();
    local_InputStream.read((char *)octreeHdr,6*sizeof(unsigned int));
    if(this->m_ByteOrder != this->m_MachineByteOrder)
      {
      if ( m_MachineByteOrder == LittleEndian )
        {
        ByteSwapper<unsigned int>::
          SwapRangeFromSystemToBigEndian( octreeHdr,6 );
        }
      else
        {
        ByteSwapper<unsigned int>::
          SwapRangeFromSystemToLittleEndian( octreeHdr,6 );
        }
      }
    this->m_Octree.setDepth(octreeHdr[0]);
    this->m_Octree.setWidth(octreeHdr[1]);
    this->m_Octree.setTrueDims(octreeHdr[2],octreeHdr[3],octreeHdr[4]);

    switch (octreeHdr[5])
      {
      case B2_MASKFILE_WHITE:
        //NOTE: THIS ALMOST NEVER HAPPENS!! All white image
        this->m_Octree.SetColor(DEF_WHITE_MASK);
        break;
      case B2_MASKFILE_BLACK:
        //NOTE: THIS ALMOST NEVER HAPPENS!! All black image
        this->m_Octree.SetColor(0);
        break;
      case B2_MASKFILE_GRAY:
        this->m_Octree.SetBranch(readOctree(local_InputStream,this->m_MachineByteOrder,this->m_ByteOrder ));
        //if(this->m_Octree.m_Children == NULL)
        //{//Determine if error occurred
        //    ExceptionObject exception(__FILE__, __LINE__);
        //    exception.SetDescription("Error in OctreeCreation");
        //    throw exception;
        //}
        break;
      }
    local_InputStream.close();
    //DEBUG: Now just convert the octree into an image for returning!!!
    //DEBUG:  This is written for 3D octreees only right now
    char * const p = static_cast<char *>(buffer);
    for(unsigned int k=0; k< this->m_Dimensions[2]; k++)
      {
      const unsigned int slice_offset=k*this->m_Dimensions[1]*this->m_Dimensions[0];
      for(unsigned int j=0; j< this->m_Dimensions[1]; j++)
        {
        const unsigned int sliceandrowoffset=slice_offset+j*this->m_Dimensions[0];
        for(unsigned int i=0; i< this->m_Dimensions[0]; i++)
          {
          p[sliceandrowoffset+i]=
            (this->m_Octree.getValue(i,this->m_Dimensions[1]-1-j,k)!=0) ?
            DEF_WHITE_MASK:0;
          }
        }
      }
    return;
  }
  // This method will only test if the header looks like an
  // B2Mask Header.  Some code is redundant with ReadImageInformation
  // a StateMachine could provide a better implementation
  bool B2MaskImageIO::CanReadFile( const char* FileNameToRead )
  {
    m_FileName=FileNameToRead;
    std::ifstream   local_InputStream;
    local_InputStream.open( FileNameToRead, std::ios::in | std::ios::binary );
    if( local_InputStream.fail() )
      {
      return false;
      }
    try
      {
      this->m_IPLHeaderInfo.ClearHeader();
      this->m_IPLHeaderInfo.ReadB2Header(local_InputStream);
      }
    catch (itk::ExceptionObject & e)
      {
      return false;
      }

    local_InputStream.close();
    if(this->m_IPLHeaderInfo.DoesKeyExist("MASK_HEADER_BEGIN")==false)
      {
      return false;
      }
    this->m_ByteOrder=(this->m_IPLHeaderInfo.getString("BYTE_ORDER:")
                       =="LITTLE_ENDIAN") ? LittleEndian : BigEndian;
    this->m_MachineByteOrder = 
      (ByteSwapper<int>::SystemIsBigEndian() == true ) ? 
      BigEndian : LittleEndian ;

    //this->m_IPLHeaderInfo.PrintSelf(std::cout);
    const int TempNumDims=this->m_IPLHeaderInfo.getInt("MASK_NUM_DIMS:");
    this->SetNumberOfDimensions(TempNumDims);
    //NOTE: B2MaskImage dim[0] are the number of dims, and dim[1..7] are the
    // actual dims.
    m_Dimensions[ 0 ] = this->m_IPLHeaderInfo.getInt("MASK_X_SIZE:");
    m_Dimensions[ 1 ] = this->m_IPLHeaderInfo.getInt("MASK_Y_SIZE:");
    m_Dimensions[ 2 ] = this->m_IPLHeaderInfo.getInt("MASK_Z_SIZE:");
    m_Spacing[ 0 ]  = this->m_IPLHeaderInfo.getFloat("MASK_X_RESOLUTION:");
    m_Spacing[ 1 ]  = this->m_IPLHeaderInfo.getFloat("MASK_Y_RESOLUTION:");
    m_Spacing[ 2 ]  = this->m_IPLHeaderInfo.getFloat("MASK_Z_RESOLUTION:");

    m_ComponentType = CHAR;
    return true;
  }

  void B2MaskImageIO::ReadImageInformation()
  {
    this->CanReadFile(this->m_FileName.c_str());
  }

  // cut the gordian knot, just do the header in one
  // long printf
static const char mask_header_format[] =
"IPL_HEADER_BEGIN\n"
"PATIENT_ID: %s\n"
"SCAN_ID: %s\n"
"FILENAME: %s\n"
"DATE: %s\n"
"CREATOR: %s\n"
"PROGRAM: %s\n"
"MODULE: %s\n"
"VERSION: %s\n"
"NAME: %s\n"
"BYTE_ORDER: BIG_ENDIA"
"MASK_HEADER_BEGI"
"MASK_NUM_DIMS: %d\n"
"MASK_X_SIZE: %d\n"
"MASK_X_RESOLUTION: %f\n"
"MASK_Y_SIZE: %d\n"
"MASK_Y_RESOLUTION: %f\n"
"MASK_Z_SIZE: %d\n"
"MASK_Z_RESOLUTION: %f\n"
"MASK_THRESHOLD: %f\n"
"MASK_NAME: %d\n"
"MASK_ACQ_PLANE: CORONAL\n"
"MASK_HEADER_END\n"
"IPL_HEADER_END\n";

  /**
   *
   */
  void
  B2MaskImageIO
  ::WriteImageInformation(void)
  {
    return;
  }

  static bool
  writeOctree (OctreeNode *branch,std::ofstream &output)
  {
    unsigned i;
    unsigned short  colorCode = 0;

    for (i = 0; i < 8; i++)
      {
      OctreeNode &subnode = 
        branch->GetChild(static_cast<enum LeafIdentifier>(i));
      if (subnode.IsNodeColored())
        {
        if(subnode.GetColor() == B2_MASKFILE_BLACK)
          {
          colorCode |= B2_MASKFILE_BLACK << (i << 1);
          }
        else
          {
          colorCode |= B2_MASKFILE_WHITE << (i << 1);
          }
        }
      else
        {
        colorCode |= B2_MASKFILE_GRAY << (i << 1);
        }
      }
    itk::ByteSwapper<unsigned short>::SwapFromSystemToBigEndian(&colorCode);
    output.write((const char *)&colorCode,sizeof(colorCode));
    for (i = 0; i < 8; i++)
      {
      OctreeNode &subnode = 
        branch->GetChild(static_cast<enum LeafIdentifier>(i));
      if (!subnode.IsNodeColored())
        {
        writeOctree (&subnode, output);
        }
      }
    return true;
  }
  /**
   *
   */
  void
  B2MaskImageIO
  ::Write( const void* buffer)
  {
    if(this->m_FileName == "") 
      {
      ExceptionObject exception(__FILE__, __LINE__);
      exception.SetDescription("Error in OctreeCreation");
      throw exception;
      }
    std::ofstream output(this->m_FileName.c_str());
    if(output.fail())
      {
      ExceptionObject exception(__FILE__, __LINE__);
      exception.SetDescription("Error in OctreeCreation");
      throw exception;
      }
      
    unsigned xsize = this->GetDimensions(0);
    unsigned ysize = this->GetDimensions(1);
    unsigned zsize = this->GetDimensions(2);
    itk::MetaDataDictionary &thisDic=this->GetMetaDataDictionary();
    std::string temp;
    std::string patient_id;
    if(itk::ExposeMetaData<std::string>(thisDic,ITK_PatientID,temp))
        {
        patient_id = temp;
        }
    // to do -- add more header crap
    //Write the image Information before writing data
    char buf[16384];
    sprintf(buf,mask_header_format,
            patient_id.c_str(),
            "",                 // scan_id
            "",                 // file_name
            "",                 // date
            "",                 // creator
            "",                 // program
            "",                 // module
            "",                 // version
            "",                 // name
            3,                  // num_dims
            xsize,              // xsize
            1.0,                // x_res
            ysize,              // ysize
            1.0,                // y_res
            zsize,              // zsize
            1.0,                // z_res
            0.0,                // threshold
            -1                 // mask_name
            );
    output.write(buf,strlen(buf));
    m_Octree.setTrueDims(xsize,ysize,zsize);
          
    unsigned maxSize = xsize >= ysize ?
      (xsize >= zsize ? xsize : zsize) :
      (ysize >= zsize ? ysize : zsize);
    unsigned width = 1;
    unsigned depth = 0;
    while(width < maxSize)
      {
      width *= 2;
      depth++;
      }
    m_Octree.setDepth(depth);
    m_Octree.setWidth(width);
    switch(m_PixelType)
      {
      case CHAR:
        m_Octree.SetBranch(pv_maskToOctree<char>(buffer,
                                                 width,
                                                 0,0,0,
                                                 xsize,ysize,zsize));
        break;
      case UCHAR:
        m_Octree.SetBranch(pv_maskToOctree<unsigned char>(buffer,
                                                          width,
                                                          0,0,0,
                                                          xsize,ysize,zsize));
        break;
      case SHORT:
        m_Octree.SetBranch(pv_maskToOctree<short>(buffer,
                                                  width,
                                                  0,0,0,
                                                  xsize,ysize,zsize));
        break;
      case USHORT:
        m_Octree.SetBranch(pv_maskToOctree<unsigned short>(buffer,
                                                           width,
                                                           0,0,0,
                                                           xsize,ysize,zsize));
        break;
      case INT:
        m_Octree.SetBranch(pv_maskToOctree<int>(buffer,
                                                width,
                                                0,0,0,
                                                xsize,ysize,zsize));
        break;
      case UINT:
        m_Octree.SetBranch(pv_maskToOctree<unsigned int>(buffer,
                                                         width,
                                                         0,0,0,
                                                         xsize,ysize,zsize));
        break;
      case LONG:
        m_Octree.SetBranch(pv_maskToOctree<long>(buffer,
                                                 width,
                                                 0,0,0,
                                                 xsize,ysize,zsize));
        break;
      case ULONG:
        m_Octree.SetBranch(pv_maskToOctree<unsigned long>(buffer,
                                                          width,
                                                          0,0,0,
                                                          xsize,ysize,zsize));
        break;
      case FLOAT:
        m_Octree.SetBranch(pv_maskToOctree<float>(buffer,
                                                  width,
                                                  0,0,0,
                                                  xsize,ysize,zsize));
        break;
      case DOUBLE:
        m_Octree.SetBranch(pv_maskToOctree<double>(buffer,
                                                   width,
                                                   0,0,0,
                                                   xsize,ysize,zsize));
        break;
      default:
        ExceptionObject exception(__FILE__, __LINE__);
        exception.SetDescription("Pixel Type Unknown");
        throw exception;
      }
    //
    // one hopes now that the mask tree has been set up...
    unsigned octreeHdr[6];
    octreeHdr[0] = depth;
    octreeHdr[1] = width;
    octreeHdr[2] = xsize;
    octreeHdr[3] = ysize;
    octreeHdr[4] = zsize;
    if(m_Octree.IsNodeColored())
      {
      octreeHdr[5] = m_Octree.GetColor();
      }
    else
      {
      octreeHdr[5] = B2_MASKFILE_GRAY;
      }
    itk::ByteSwapper<unsigned>::SwapRangeFromSystemToBigEndian(octreeHdr,
                                                               6);
    output.write((const char *)octreeHdr,sizeof(unsigned)*6);

    if(!m_Octree.IsNodeColored())
      {
      writeOctree(&m_Octree,output);
      }
    output.close();
  }
} // end namespace itk
